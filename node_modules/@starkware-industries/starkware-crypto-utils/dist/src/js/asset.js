"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAssetId = exports.getAssetSelector = exports.getAssetType = void 0;
var assert_1 = __importDefault(require("assert"));
var bn_js_1 = __importDefault(require("bn.js"));
var encUtils = __importStar(require("enc-utils"));
var js_sha3_1 = __importDefault(require("js-sha3"));
var oneBn = new bn_js_1.default('1', 16);
var mask = new bn_js_1.default('3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
var mask240 = new bn_js_1.default('ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff', 16);
var maskMintabilityBit = new bn_js_1.default('400000000000000000000000000000000000000000000000000000000000000', 16);
function getAssetType(assetDict) {
    var assetSelector = getAssetSelector(assetDict.type);
    var expectedLen = encUtils.removeHexPrefix(assetSelector).length;
    var assetInfo = new bn_js_1.default(encUtils.removeHexPrefix(assetSelector), 16);
    if (assetDict.data.tokenAddress !== undefined) {
        var tokenAddress = new bn_js_1.default(encUtils.removeHexPrefix(assetDict.data.tokenAddress), 16);
        assetInfo = assetInfo.ushln(256).add(tokenAddress);
        expectedLen += 64;
    }
    var quantInfo = assetDict.data.quantum;
    var quantum = quantInfo === undefined ? oneBn : new bn_js_1.default(quantInfo, 10);
    assetInfo = assetInfo.ushln(256).add(quantum);
    expectedLen += 64;
    var assetEncoded = js_sha3_1.default.keccak_256(encUtils.hexToBuffer(addLeadingZeroes(assetInfo.toJSON(), expectedLen)));
    var assetType = new bn_js_1.default(assetEncoded, 16);
    assetType = assetType.and(mask);
    return '0x' + assetType.toJSON();
}
exports.getAssetType = getAssetType;
function getAssetId(assetDict) {
    var assetType = new bn_js_1.default(encUtils.removeHexPrefix(getAssetType(assetDict)), 16);
    var assetId = assetType;
    if (assetDict.type === 'ERC721') {
        var assetInfo = new bn_js_1.default(encUtils.utf8ToBuffer('NFT:'), 16);
        var expectedLen = 8 + 64 + 64;
        assetInfo = assetInfo.ushln(256).add(assetType);
        assetInfo = assetInfo
            .ushln(256)
            .add(new bn_js_1.default(parseInt(assetDict.data.tokenId), 16));
        var assetEncoded = js_sha3_1.default.keccak_256(encUtils.hexToBuffer(addLeadingZeroes(assetInfo.toJSON(), expectedLen)));
        assetId = new bn_js_1.default(assetEncoded, 16);
        assetId = assetId.and(mask);
    }
    else if (assetDict.type === 'MINTABLE_ERC721' ||
        assetDict.type === 'MINTABLE_ERC20') {
        var assetInfo = new bn_js_1.default(encUtils.utf8ToBuffer('MINTABLE:'), 16);
        var expectedLen = 18 + 64 + 64;
        assetInfo = assetInfo.ushln(256).add(assetType);
        var blobHash = blobToBlobHash(assetDict.data.blob);
        assetInfo = assetInfo
            .ushln(256)
            .add(new bn_js_1.default(encUtils.removeHexPrefix(blobHash), 16));
        var assetEncoded = js_sha3_1.default.keccak_256(encUtils.hexToBuffer(addLeadingZeroes(assetInfo.toJSON(), expectedLen)));
        assetId = new bn_js_1.default(assetEncoded, 16);
        assetId = assetId.and(mask240);
        assetId = assetId.or(maskMintabilityBit);
    }
    return '0x' + assetId.toJSON();
}
exports.getAssetId = getAssetId;
function getAssetSelector(assetDictType) {
    var seed = '';
    switch (assetDictType.toUpperCase()) {
        case 'ETH':
            seed = 'ETH()';
            break;
        case 'ERC20':
            seed = 'ERC20Token(address)';
            break;
        case 'ERC721':
            seed = 'ERC721Token(address,uint256)';
            break;
        case 'MINTABLE_ERC20':
            seed = 'MintableERC20Token(address)';
            break;
        case 'MINTABLE_ERC721':
            seed = 'MintableERC721Token(address,uint256)';
            break;
        default:
            throw new Error("Unknown token type: ".concat(assetDictType));
    }
    return encUtils.sanitizeHex(js_sha3_1.default.keccak_256(seed).slice(0, 8));
}
exports.getAssetSelector = getAssetSelector;
function addLeadingZeroes(hexStr, expectedLen) {
    var res = hexStr;
    (0, assert_1.default)(res.length <= expectedLen);
    while (res.length < expectedLen) {
        res = '0' + res;
    }
    return res;
}
function blobToBlobHash(blob) {
    return '0x' + js_sha3_1.default.keccak_256(blob);
}
//# sourceMappingURL=asset.js.map