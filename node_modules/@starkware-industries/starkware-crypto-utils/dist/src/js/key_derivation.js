"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.grindKey = exports.getAccountPath = exports.getKeyPairFromPath = exports.privateToStarkKey = exports.getPrivateKeyFromEthSignature = exports.StarkExEc = void 0;
var assert_1 = __importDefault(require("assert"));
var bip39 = __importStar(require("bip39"));
var bn_js_1 = __importDefault(require("bn.js"));
var encUtils = __importStar(require("enc-utils"));
var ethereumjs_wallet_1 = require("ethereumjs-wallet");
var hash_js_1 = __importDefault(require("hash.js"));
var signature_1 = require("./signature");
var ETH_SIGNATURE_LENGTH = 130;
var STARK_PRIVATE_KEY_LENGTH = 63;
function getIntFromBits(hex, start, end) {
    if (end === void 0) { end = undefined; }
    var bin = encUtils.hexToBinary(hex);
    var bits = bin.slice(start, end);
    var int = encUtils.binaryToNumber(bits);
    return int;
}
function isHexOfLength(hex, hexLength) {
    var regex = new RegExp('^[0-9a-fA-F]{' + hexLength + '}$');
    return regex.test(hex);
}
function getPrivateKeyFromEthSignature(ethSignature) {
    var ethSignatureFixed = ethSignature.replace(/^0x/, '');
    (0, assert_1.default)(isHexOfLength(ethSignatureFixed, ETH_SIGNATURE_LENGTH));
    var r = ethSignatureFixed.substring(0, 64);
    return grindKey(r, signature_1.ec.n);
}
exports.getPrivateKeyFromEthSignature = getPrivateKeyFromEthSignature;
function privateToStarkKey(privateKey) {
    var privateKeyFixed = privateKey.replace(/^0x/, '');
    (0, assert_1.default)(privateKeyFixed.length <= STARK_PRIVATE_KEY_LENGTH);
    (0, assert_1.default)(isHexOfLength(privateKeyFixed, privateKeyFixed.length));
    var keyPair = signature_1.ec.keyFromPrivate(privateKeyFixed, 'hex');
    return keyPair.getPublic().getX().toJSON();
}
exports.privateToStarkKey = privateToStarkKey;
function getKeyPairFromPath(mnemonic, path) {
    var seed = bip39.mnemonicToSeedSync(mnemonic);
    var keySeed = ethereumjs_wallet_1.hdkey
        .fromMasterSeed(seed)
        .derivePath(path)
        .getWallet()
        .getPrivateKeyString();
    var starkEcOrder = signature_1.ec.n;
    return signature_1.ec.keyFromPrivate(grindKey(keySeed, starkEcOrder), 'hex');
}
exports.getKeyPairFromPath = getKeyPairFromPath;
function getAccountPath(layer, application, ethereumAddress, index) {
    var layerHash = hash_js_1.default.sha256().update(layer).digest('hex');
    var applicationHash = hash_js_1.default.sha256().update(application).digest('hex');
    var layerInt = getIntFromBits(layerHash, -31);
    var applicationInt = getIntFromBits(applicationHash, -31);
    var ethAddressInt1 = getIntFromBits(ethereumAddress, -31);
    var ethAddressInt2 = getIntFromBits(ethereumAddress, -62, -31);
    return "m/2645'/".concat(layerInt, "'/").concat(applicationInt, "'/").concat(ethAddressInt1, "'/").concat(ethAddressInt2, "'/").concat(index);
}
exports.getAccountPath = getAccountPath;
function grindKey(keySeed, keyValLimit) {
    var sha256EcMaxDigest = new bn_js_1.default('1 00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000', 16);
    var maxAllowedVal = sha256EcMaxDigest.sub(sha256EcMaxDigest.mod(keyValLimit));
    var i = 0;
    var key = hashKeyWithIndex(keySeed, i);
    i++;
    while (!key.lt(maxAllowedVal)) {
        key = hashKeyWithIndex(keySeed, i);
        i++;
    }
    return key.umod(keyValLimit).toString('hex');
}
exports.grindKey = grindKey;
function hashKeyWithIndex(key, index) {
    return new bn_js_1.default(hash_js_1.default
        .sha256()
        .update(encUtils.hexToBuffer(encUtils.removeHexPrefix(key) +
        encUtils.sanitizeBytes(encUtils.numberToHex(index), 2)))
        .digest('hex'), 16);
}
var StarkExEc = signature_1.ec.n;
exports.StarkExEc = StarkExEc;
//# sourceMappingURL=key_derivation.js.map