"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLimitOrderMsgHashWithFee = exports.getTransferMsgHashWithFee = exports.assertInMultiRange = exports.assertInRange = exports.verify = exports.sign = exports.getTransferMsgHash = exports.getLimitOrderMsgHash = exports.pedersen = exports.Range = exports.maxEcdsaVal = exports.shiftPoint = exports.constantPoints = exports.ec = exports.prime = void 0;
var assert_1 = __importDefault(require("assert"));
var bn_js_1 = __importDefault(require("bn.js"));
var elliptic_1 = require("elliptic");
var hash_js_1 = __importDefault(require("hash.js"));
var constant_points_json_1 = __importDefault(require("../config/constant_points.json"));
var message_utils_1 = require("./message_utils");
Object.defineProperty(exports, "Range", { enumerable: true, get: function () { return message_utils_1.Range; } });
Object.defineProperty(exports, "assertInMultiRange", { enumerable: true, get: function () { return message_utils_1.assertInMultiRange; } });
Object.defineProperty(exports, "assertInRange", { enumerable: true, get: function () { return message_utils_1.assertInRange; } });
var prime = new bn_js_1.default('800000000000011000000000000000000000000000000000000000000000001', 16);
exports.prime = prime;
var maxEcdsaVal = new bn_js_1.default('800000000000000000000000000000000000000000000000000000000000000', 16);
exports.maxEcdsaVal = maxEcdsaVal;
var zeroBn = new bn_js_1.default('0', 16);
var oneBn = new bn_js_1.default('1', 16);
var twoBn = new bn_js_1.default('2', 16);
var threeBn = new bn_js_1.default('3', 16);
var fourBn = new bn_js_1.default('4', 16);
var fiveBn = new bn_js_1.default('5', 16);
var twoPow22Bn = new bn_js_1.default('400000', 16);
var twoPow31Bn = new bn_js_1.default('80000000', 16);
var twoPow63Bn = new bn_js_1.default('8000000000000000', 16);
var vaultIDAllowedRanges = [
    new message_utils_1.Range(zeroBn, twoPow31Bn),
    new message_utils_1.Range(twoPow63Bn, twoPow63Bn.add(twoPow31Bn))
];
var starkEc = new elliptic_1.ec(new elliptic_1.curves.PresetCurve({
    type: 'short',
    prime: null,
    p: prime,
    a: '00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000001',
    b: '06f21413 efbe40de 150e596d 72f7a8c5 609ad26c 15c915c1 f4cdfcb9 9cee9e89',
    n: '08000000 00000010 ffffffff ffffffff b781126d cae7b232 1e66a241 adc64d2f',
    hash: hash_js_1.default.sha256,
    gRed: false,
    g: constant_points_json_1.default[1]
}));
exports.ec = starkEc;
var constantPoints = constant_points_json_1.default.map(function (coords) {
    return starkEc.curve.point(new bn_js_1.default(coords[0], 16), new bn_js_1.default(coords[1], 16));
});
exports.constantPoints = constantPoints;
var shiftPoint = constantPoints[0];
exports.shiftPoint = shiftPoint;
function hasHexPrefix(str) {
    return str.substring(0, 2) === '0x';
}
function pedersen(input) {
    var point = shiftPoint;
    for (var i = 0; i < input.length; i++) {
        var x = new bn_js_1.default(input[i], 16);
        (0, assert_1.default)(x.gte(zeroBn) && x.lt(prime), 'Invalid input: ' + input[i]);
        for (var j = 0; j < 252; j++) {
            var pt = constantPoints[2 + i * 252 + j];
            (0, assert_1.default)(!point.getX().eq(pt.getX()));
            if (x.and(oneBn).toNumber() !== 0) {
                point = point.add(pt);
            }
            x = x.shrn(1);
        }
    }
    return point.getX().toString(16);
}
exports.pedersen = pedersen;
function hashMsg(instructionTypeBn, vault0Bn, vault1Bn, amount0Bn, amount1Bn, nonceBn, expirationTimestampBn, token0, token1OrPubKey, condition) {
    if (condition === void 0) { condition = null; }
    var packedMessage = instructionTypeBn;
    packedMessage = packedMessage.ushln(31).add(vault0Bn);
    packedMessage = packedMessage.ushln(31).add(vault1Bn);
    packedMessage = packedMessage.ushln(63).add(amount0Bn);
    packedMessage = packedMessage.ushln(63).add(amount1Bn);
    packedMessage = packedMessage.ushln(31).add(nonceBn);
    packedMessage = packedMessage.ushln(22).add(expirationTimestampBn);
    var msgHash = null;
    if (condition === null) {
        msgHash = pedersen([
            pedersen([token0, token1OrPubKey]),
            packedMessage.toString(16)
        ]);
    }
    else {
        msgHash = pedersen([
            pedersen([pedersen([token0, token1OrPubKey]), condition]),
            packedMessage.toString(16)
        ]);
    }
    var msgHashBN = new bn_js_1.default(msgHash, 16);
    (0, message_utils_1.assertInRange)(msgHashBN, zeroBn, maxEcdsaVal, 'msgHash');
    return msgHash;
}
function hashTransferMsgWithFee(instructionTypeBn, senderVaultIdBn, receiverVaultIdBn, amountBn, nonceBn, expirationTimestampBn, transferToken, receiverPublicKey, feeToken, feeVaultIdBn, feeLimitBn, condition) {
    if (condition === void 0) { condition = null; }
    var packedMessage1 = senderVaultIdBn;
    packedMessage1 = packedMessage1.ushln(64).add(receiverVaultIdBn);
    packedMessage1 = packedMessage1.ushln(64).add(feeVaultIdBn);
    packedMessage1 = packedMessage1.ushln(32).add(nonceBn);
    var packedMessage2 = instructionTypeBn;
    packedMessage2 = packedMessage2.ushln(64).add(amountBn);
    packedMessage2 = packedMessage2.ushln(64).add(feeLimitBn);
    packedMessage2 = packedMessage2.ushln(32).add(expirationTimestampBn);
    packedMessage2 = packedMessage2.ushln(81).add(zeroBn);
    var msgHash = null;
    var tmpHash = pedersen([
        pedersen([transferToken, feeToken]),
        receiverPublicKey
    ]);
    if (condition === null) {
        msgHash = pedersen([
            pedersen([tmpHash, packedMessage1.toString(16)]),
            packedMessage2.toString(16)
        ]);
    }
    else {
        msgHash = pedersen([
            pedersen([pedersen([tmpHash, condition]), packedMessage1.toString(16)]),
            packedMessage2.toString(16)
        ]);
    }
    var msgHashBN = new bn_js_1.default(msgHash, 16);
    (0, message_utils_1.assertInRange)(msgHashBN, zeroBn, maxEcdsaVal, 'msgHash');
    return msgHash;
}
function hashLimitOrderMsgWithFee(instructionTypeBn, vaultSellBn, vaultBuyBn, amountSellBn, amountBuyBn, nonceBn, expirationTimestampBn, tokenSell, tokenBuy, feeToken, feeVaultIdBn, feeLimitBn) {
    var packedMessage1 = amountSellBn;
    packedMessage1 = packedMessage1.ushln(64).add(amountBuyBn);
    packedMessage1 = packedMessage1.ushln(64).add(feeLimitBn);
    packedMessage1 = packedMessage1.ushln(32).add(nonceBn);
    var packedMessage2 = instructionTypeBn;
    packedMessage2 = packedMessage2.ushln(64).add(feeVaultIdBn);
    packedMessage2 = packedMessage2.ushln(64).add(vaultSellBn);
    packedMessage2 = packedMessage2.ushln(64).add(vaultBuyBn);
    packedMessage2 = packedMessage2.ushln(32).add(expirationTimestampBn);
    packedMessage2 = packedMessage2.ushln(17).add(zeroBn);
    var msgHash = null;
    var tmpHash = pedersen([pedersen([tokenSell, tokenBuy]), feeToken]);
    msgHash = pedersen([
        pedersen([tmpHash, packedMessage1.toString(16)]),
        packedMessage2.toString(16)
    ]);
    var msgHashBN = new bn_js_1.default(msgHash, 16);
    (0, message_utils_1.assertInRange)(msgHashBN, zeroBn, maxEcdsaVal, 'msgHash');
    return msgHash;
}
function getLimitOrderMsgHash(vaultSell, vaultBuy, amountSell, amountBuy, tokenSell, tokenBuy, nonce, expirationTimestamp) {
    (0, assert_1.default)(hasHexPrefix(tokenSell) && hasHexPrefix(tokenBuy), 'Hex strings expected to be prefixed with 0x.');
    var vaultSellBn = new bn_js_1.default(vaultSell);
    var vaultBuyBn = new bn_js_1.default(vaultBuy);
    var amountSellBn = new bn_js_1.default(amountSell, 10);
    var amountBuyBn = new bn_js_1.default(amountBuy, 10);
    var tokenSellBn = new bn_js_1.default(tokenSell.substring(2), 16);
    var tokenBuyBn = new bn_js_1.default(tokenBuy.substring(2), 16);
    var nonceBn = new bn_js_1.default(nonce);
    var expirationTimestampBn = new bn_js_1.default(expirationTimestamp);
    (0, message_utils_1.assertInRange)(vaultSellBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(vaultBuyBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(amountSellBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(amountBuyBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(tokenSellBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(tokenBuyBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(nonceBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(expirationTimestampBn, zeroBn, twoPow22Bn);
    var instructionType = zeroBn;
    return hashMsg(instructionType, vaultSellBn, vaultBuyBn, amountSellBn, amountBuyBn, nonceBn, expirationTimestampBn, tokenSell.substring(2), tokenBuy.substring(2));
}
exports.getLimitOrderMsgHash = getLimitOrderMsgHash;
function getLimitOrderMsgHashWithFee(vaultSell, vaultBuy, amountSell, amountBuy, tokenSell, tokenBuy, nonce, expirationTimestamp, feeToken, feeVaultId, feeLimit) {
    (0, assert_1.default)(hasHexPrefix(tokenSell) && hasHexPrefix(tokenBuy), 'Hex strings expected to be prefixed with 0x.');
    var vaultSellBn = new bn_js_1.default(vaultSell);
    var vaultBuyBn = new bn_js_1.default(vaultBuy);
    var amountSellBn = new bn_js_1.default(amountSell, 10);
    var amountBuyBn = new bn_js_1.default(amountBuy, 10);
    var tokenSellBn = new bn_js_1.default(tokenSell.substring(2), 16);
    var tokenBuyBn = new bn_js_1.default(tokenBuy.substring(2), 16);
    var nonceBn = new bn_js_1.default(nonce);
    var expirationTimestampBn = new bn_js_1.default(expirationTimestamp);
    var feeTokenBn = new bn_js_1.default(feeToken);
    var feeVaultIdBn = new bn_js_1.default(feeVaultId);
    var feeLimitBn = new bn_js_1.default(feeLimit);
    (0, message_utils_1.assertInMultiRange)(vaultSellBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInMultiRange)(vaultBuyBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInRange)(amountSellBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(amountBuyBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(tokenSellBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(tokenBuyBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(nonceBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(expirationTimestampBn, zeroBn, twoPow22Bn);
    (0, message_utils_1.assertInRange)(feeTokenBn, zeroBn, prime);
    (0, message_utils_1.assertInMultiRange)(feeVaultIdBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInRange)(feeLimitBn, zeroBn, twoPow63Bn);
    var instructionType = threeBn;
    return hashLimitOrderMsgWithFee(instructionType, vaultSellBn, vaultBuyBn, amountSellBn, amountBuyBn, nonceBn, expirationTimestampBn, tokenSell.substring(2), tokenBuy.substring(2), feeToken.substring(2), feeVaultIdBn, feeLimitBn);
}
exports.getLimitOrderMsgHashWithFee = getLimitOrderMsgHashWithFee;
function getTransferMsgHash(amount, nonce, senderVaultId, token, receiverVaultId, receiverPublicKey, expirationTimestamp, condition) {
    if (condition === void 0) { condition = null; }
    (0, assert_1.default)(hasHexPrefix(token) &&
        hasHexPrefix(receiverPublicKey) &&
        (condition === null || hasHexPrefix(condition)), 'Hex strings expected to be prefixed with 0x.');
    var amountBn = new bn_js_1.default(amount, 10);
    var nonceBn = new bn_js_1.default(nonce);
    var senderVaultIdBn = new bn_js_1.default(senderVaultId);
    var tokenBn = new bn_js_1.default(token.substring(2), 16);
    var receiverVaultIdBn = new bn_js_1.default(receiverVaultId);
    var receiverPublicKeyBn = new bn_js_1.default(receiverPublicKey.substring(2), 16);
    var expirationTimestampBn = new bn_js_1.default(expirationTimestamp);
    (0, message_utils_1.assertInRange)(amountBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(nonceBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(senderVaultIdBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(tokenBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(receiverVaultIdBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInRange)(receiverPublicKeyBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(expirationTimestampBn, zeroBn, twoPow22Bn);
    var instructionType = oneBn;
    if (condition !== null) {
        condition = condition.substring(2);
        (0, message_utils_1.assertInRange)(new bn_js_1.default(condition), zeroBn, prime, 'condition');
        instructionType = twoBn;
    }
    return hashMsg(instructionType, senderVaultIdBn, receiverVaultIdBn, amountBn, zeroBn, nonceBn, expirationTimestampBn, token.substring(2), receiverPublicKey.substring(2), condition);
}
exports.getTransferMsgHash = getTransferMsgHash;
function getTransferMsgHashWithFee(amount, nonce, senderVaultId, token, receiverVaultId, receiverStarkKey, expirationTimestamp, feeToken, feeVaultId, feeLimit, condition) {
    if (condition === void 0) { condition = null; }
    (0, assert_1.default)(hasHexPrefix(feeToken) &&
        hasHexPrefix(token) &&
        hasHexPrefix(receiverStarkKey) &&
        (condition === null || hasHexPrefix(condition)), 'Hex strings expected to be prefixed with 0x.');
    var amountBn = new bn_js_1.default(amount, 10);
    var nonceBn = new bn_js_1.default(nonce);
    var senderVaultIdBn = new bn_js_1.default(senderVaultId);
    var tokenBn = new bn_js_1.default(token.substring(2), 16);
    var receiverVaultIdBn = new bn_js_1.default(receiverVaultId);
    var receiverStarkKeyBn = new bn_js_1.default(receiverStarkKey.substring(2), 16);
    var expirationTimestampBn = new bn_js_1.default(expirationTimestamp);
    var feeTokenBn = new bn_js_1.default(feeToken);
    var feeVaultIdBn = new bn_js_1.default(feeVaultId);
    var feeLimitBn = new bn_js_1.default(feeLimit);
    (0, message_utils_1.assertInRange)(amountBn, zeroBn, twoPow63Bn);
    (0, message_utils_1.assertInRange)(nonceBn, zeroBn, twoPow31Bn);
    (0, message_utils_1.assertInMultiRange)(senderVaultIdBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInRange)(tokenBn, zeroBn, prime);
    (0, message_utils_1.assertInMultiRange)(receiverVaultIdBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInRange)(receiverStarkKeyBn, zeroBn, prime);
    (0, message_utils_1.assertInRange)(expirationTimestampBn, zeroBn, twoPow22Bn);
    (0, message_utils_1.assertInRange)(feeTokenBn, zeroBn, prime);
    (0, message_utils_1.assertInMultiRange)(feeVaultIdBn, vaultIDAllowedRanges);
    (0, message_utils_1.assertInRange)(feeLimitBn, zeroBn, twoPow63Bn);
    var instructionType = fourBn;
    if (condition !== null) {
        condition = condition.substring(2);
        (0, message_utils_1.assertInRange)(new bn_js_1.default(condition), zeroBn, prime, 'condition');
        instructionType = fiveBn;
    }
    return hashTransferMsgWithFee(instructionType, senderVaultIdBn, receiverVaultIdBn, amountBn, nonceBn, expirationTimestampBn, token.substring(2), receiverStarkKey.substring(2), feeToken.substring(2), feeVaultIdBn, feeLimitBn, condition);
}
exports.getTransferMsgHashWithFee = getTransferMsgHashWithFee;
function fixMsgHashLen(msgHash) {
    msgHash = new bn_js_1.default(msgHash, 16).toString(16);
    if (msgHash.length <= 62) {
        return msgHash;
    }
    (0, assert_1.default)(msgHash.length === 63);
    return msgHash + '0';
}
function sign(privateKey, msgHash) {
    var msgHashBN = new bn_js_1.default(msgHash, 16);
    (0, message_utils_1.assertInRange)(msgHashBN, zeroBn, maxEcdsaVal, 'msgHash');
    var msgSignature = privateKey.sign(fixMsgHashLen(msgHash));
    var r = msgSignature.r, s = msgSignature.s;
    var w = s.invm(starkEc.n);
    (0, message_utils_1.assertInRange)(r, oneBn, maxEcdsaVal, 'r');
    (0, message_utils_1.assertInRange)(s, oneBn, starkEc.n, 's');
    (0, message_utils_1.assertInRange)(w, oneBn, maxEcdsaVal, 'w');
    return msgSignature;
}
exports.sign = sign;
function verify(publicKey, msgHash, msgSignature) {
    var msgHashBN = new bn_js_1.default(msgHash, 16);
    (0, message_utils_1.assertInRange)(msgHashBN, zeroBn, maxEcdsaVal, 'msgHash');
    var r = msgSignature.r, s = msgSignature.s;
    var w = s.invm(starkEc.n);
    (0, message_utils_1.assertInRange)(r, oneBn, maxEcdsaVal, 'r');
    (0, message_utils_1.assertInRange)(s, oneBn, starkEc.n, 's');
    (0, message_utils_1.assertInRange)(w, oneBn, maxEcdsaVal, 'w');
    return publicKey.verify(fixMsgHashLen(msgHash), msgSignature);
}
exports.verify = verify;
//# sourceMappingURL=signature.js.map